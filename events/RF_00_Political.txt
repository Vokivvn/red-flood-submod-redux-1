###########################
# Political Events
###########################

add_namespace = rf.political

#####################
### Returning Cores to Allies ###
#####################

# Which cores to return?
country_event = {
	id = rf.political.1
	title = rf.political.1t
	desc = rf.political.d
	picture = GFX_report_event_generic_diplomacy2

	is_triggered_only = yes

	option = {
		log = "[GetLogInfo]: event rf.political.1 option rf.political.1.a"
		name = rf.political.1.a #return all land
		ai_chance = { base = 1 }
		clr_country_flag = RF_returning_land
		custom_effect_tooltip = RF_will_return_all
		hidden_effect = {
			event_target:return_to = {
				country_event = rf.political.2
			}
		}
	}
	option = {
		log = "[GetLogInfo]: event rf.political.1 option rf.political.1.b"
		name = rf.political.1.b #return all land but vital provinces
		trigger = {
			any_owned_state = {
				OR = {
					is_core_of = event_target:return_to
					is_claimed_by = event_target:return_to
				}
				is_claim_or_core_of_ROOT = no
				is_important_state = yes
				#NOT = { has_variable = can_integrate_@ROOT }
				#NOT = { any_country_with_core = { has_variable = ROOT.can_integrate_@THIS } }
				NOT = { has_state_flag = KR_keeping_state@ROOT }
			}
		}
		ai_chance = { base = 100 }
		custom_effect_tooltip = RF_will_return_rest
		hidden_effect = {
			clr_country_flag = RF_returning_land
			every_owned_state = {
				limit = {
					OR = {
						is_core_of = event_target:return_to
						is_claimed_by = event_target:return_to
					}
					is_claim_or_core_of_ROOT = no
					is_important_state = yes
					NOT = { has_state_flag = RF_keeping_state@ROOT }
				}
				set_state_flag = RF_keeping_state@ROOT
			}
			if = {
				limit = {
					any_owned_state = {
						OR = {
							is_core_of = event_target:return_to
							is_claimed_by = event_target:return_to
						}
						is_claim_or_core_of_ROOT = no
						is_important_state = no
						#NOT = { has_variable = can_integrate_@ROOT }
						#NOT = { any_country_with_core = { has_variable = ROOT.can_integrate_@THIS } }
						NOT = { has_state_flag = KR_keeping_state@ROOT }
						OR = {
							is_coastal = yes
							any_neighbor_state = { is_owned_by = event_target:return_to }
						}
					}
				}
				event_target:return_to = {
					country_event = rf.political.2
				}
			}
		}
	}
	option = {
		log = "[GetLogInfo]: event rf.political.1 option rf.political.1.c"
		name = rf.political.1.c #return cores only
		trigger = {
			is_ai = no
			any_owned_state = {
				is_claim_or_core_of_ROOT = no
				is_important_state = no
				#NOT = { has_variable = can_integrate_@ROOT }
				#NOT = { any_country_with_core = { has_variable = ROOT.can_integrate_@THIS } }
				NOT = { has_state_flag = KR_keeping_state@ROOT }
				is_core_of = event_target:return_to
			}
			any_owned_state = {
				is_claim_or_core_of_ROOT = no
				is_important_state = no
				#NOT = { has_variable = can_integrate_@ROOT }
				#NOT = { any_country_with_core = { has_variable = ROOT.can_integrate_@THIS } }
				NOT = { has_state_flag = RF_keeping_state@ROOT }
				NOT = { is_core_of = event_target:return_to }
				is_claimed_by = event_target:return_to
			}
		}
		custom_effect_tooltip = RF_will_return_cores
		hidden_effect = {
			clr_country_flag = RF_returning_land
			every_owned_state = {
				limit = {
					is_claim_or_core_of_ROOT = no
					#NOT = { has_variable = can_integrate_@ROOT }
					#NOT = { any_country_with_core = { has_variable = ROOT.can_integrate_@THIS } }
					NOT = { has_state_flag = KR_keeping_state@ROOT }
					NOT = { is_core_of = event_target:return_to }
					is_claimed_by = event_target:return_to
				}
				set_state_flag = RF_keeping_state@ROOT
			}
			event_target:return_to = {
				country_event = rf.political.2
			}
		}
	}
	option = {
		log = "[GetLogInfo]: event rf.political.1 option rf.political.1.e"
		name = rf.political.1.e #keep it all you pig
		ai_chance = { base = 0 }
		clr_country_flag = RF_returning_land
		custom_effect_tooltip = RF_will_not_return
		hidden_effect = {
			every_owned_state = {
				limit = {
					OR = {
						is_core_of = event_target:return_to
						is_claimed_by = event_target:return_to
					}
					is_claim_or_core_of_ROOT = no
					#NOT = { has_variable = can_integrate_@ROOT }
					#NOT = { any_country_with_core = { has_variable = ROOT.can_integrate_@THIS } }
					NOT = { has_state_flag = KR_keeping_state@ROOT }
				}
				set_state_flag = RF_keeping_state@ROOT
			}
		}
	}
}

# Cores/claims have been returned by an ally
country_event = {
	id = rf.political.2
	title = rf.political.2.t
	desc = rf.political.2.d
	picture = GFX_report_event_generic_diplomacy2

	is_triggered_only = yes

	option = {
		log = "[GetLogInfo]: event rf.political.2 option rf.political.2.a"
		name = rf.political.2.a
		set_temp_variable = { tag_to_release = ROOT }
		while_loop_effect = {
			limit = {
				FROM = {
					any_owned_state = {
						is_claim_or_core_of_ROOT = yes
						is_claim_or_core_of_FROM = no
						#NOT = { has_variable = can_integrate_@FROM }
						#NOT = { any_country_with_core = { has_variable = FROM.can_integrate_@THIS } }
						OR = {
							is_coastal = yes
							any_neighbor_state = { is_owned_by = ROOT }
						}
						NOT = { has_state_flag = RF_keeping_state@FROM }
					}
				}
			}
			FROM = {
				every_owned_state = {
					limit = {
						is_claim_or_core_of_ROOT = yes
						is_claim_or_core_of_FROM = no
						#NOT = { has_variable = can_integrate_@FROM }
						#NOT = { any_country_with_core = { has_variable = FROM.can_integrate_@THIS } }
						OR = {
							is_coastal = yes
							any_neighbor_state = { is_owned_by = ROOT }
						}
						NOT = { has_state_flag = RF_keeping_state@FROM }
					}
					transfer_state_without_overriding_occupation = yes
				}
			}
		}
	}
}

##################################
###     White Peace Events     ###
##################################

# Error checking to make sure subordinate countries peace out with the target
country_event = {
	id = rf.political.205
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.205" }

	hidden = yes
	is_triggered_only = yes

	trigger = {
		has_war_with = FROM
	}

	immediate = {
		white_peace = FROM
	}
}

country_event = {
	id = rf.political.206
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.206" }

	hidden = yes
	is_triggered_only = yes

	trigger = {
		has_war_with = event_target:peace_country
	}

	immediate = {
		white_peace = event_target:peace_country
	}
}

country_event = {
	id = rf.political.207
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.207" }

	hidden = yes
	is_triggered_only = yes

	trigger = {
		has_war_with = event_target:white_peace_receiver
	}

	immediate = {
		white_peace = event_target:white_peace_receiver
	}
}

country_event = {
	id = rf.political.208
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.208" }

	hidden = yes
	is_triggered_only = yes

	trigger = {
		event_target:factionhead = { is_faction_leader = yes }
		is_in_faction = no
		is_subject = no
	}

	immediate = {
		set_global_flag = TEMPORARY_DISABLED_FACTION_POPUP
		event_target:factionhead = { add_to_faction = ROOT }
	}
}

# Dynamically add operative nationalities
#country_event = {
#	id = rf.political.209
#	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.209" }
#
#	hidden = yes
#	is_triggered_only = yes
#
#	immediate = {
#		every_country = {
#			limit = { has_intelligence_agency = yes }
#			every_operative = { add_operative_nationalities = yes }
#		}
#	}
#}

# Calculate sent expeditionary force variables
#country_event = {
#	id = rf.political.210
#	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.210" }
#
#	hidden = yes
#	is_triggered_only = yes
#
#	option = {
#		set_variable = { expeditionary_division_sent = 0 }
#		for_each_scope_loop = {
#			array = faction_members
#			if = {
#				limit = {
#					received_expeditionary_forces = { sender = ROOT value > 0 }
#				}
#				while_loop_effect = {
#					limit = {
#						received_expeditionary_forces = { sender = ROOT value > expeditionary_division_sent }
#					}
#					add_to_variable = { expeditionary_division_sent = 1 }
#				}
#			}
#		}
#		calculate_actual_division_number = yes
#	}
#}

# Calculate received expeditionary force variables
#country_event = {
#	id = rf.political.211
#	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.211" }
#
#	hidden = yes
#	is_triggered_only = yes
#
#	option = {
#		set_variable = { num_expeditionary_divisions_received = 0 }
#		for_each_loop = {
#			array = faction_members
#			if = {
#				limit = {
#					received_expeditionary_forces = { sender = var:v value > 0 }
#				}
#				set_temp_variable = { expeditionary_division_received_temp = 0 }
#				while_loop_effect = {
#					limit = {
#						received_expeditionary_forces = { sender = var:v value > expeditionary_division_received_temp }
#					}
#					add_to_temp_variable = { expeditionary_division_received_temp = 1 }
#				}
#				add_to_variable = { num_expeditionary_divisions_received = expeditionary_division_received_temp }
#			}
#		}
#		calculate_actual_division_number = yes
#	}
#}

##################################
###	State Transfer Events   ###
##################################

# Puppeting
country_event = {
	id = rf.political.250
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.250 FROM = [From.GetName]" }
	title = rf.political.250.t
	desc = rf.political.250.d

	is_triggered_only = yes

	option = {
		name = rf.political.250.a #Regular Puppet
		if = {
			limit = {
				event_target:marked_country = { is_in_faction = yes }
				event_target:to_be_overlord = {
					is_in_faction = yes
					NOT = { is_in_faction_with = event_target:marked_country }
				}
			}
			event_target:marked_country = { leave_faction = yes }
		}
		event_target:to_be_overlord = {
			set_temp_variable = { tag_to_release = event_target:marked_country }
			puppet_released_tag = yes
		}
		if = {
			limit = {
				event_target:to_be_overlord = {
					is_in_faction = yes
					NOT = { is_in_faction_with = event_target:marked_country }
				}
			}
			event_target:to_be_overlord = {
				faction_leader = { add_to_faction = event_target:marked_country }
			}
		}
		clear_global_event_target = to_be_overlord
		add_to_variable = { ROOT.update_stt_gui = 1 }
	}
	option = {
		name = rf.political.250.b #Keep Old Government
		if = {
			limit = {
				event_target:marked_country = { is_in_faction = yes }
				event_target:to_be_overlord = {
					is_in_faction = yes
					NOT = { is_in_faction_with = event_target:marked_country }
				}
			}
			event_target:marked_country = { leave_faction = yes }
		}
		event_target:marked_country = { get_current_government_type = yes }
		custom_effect_tooltip = puppet_but_keep_government_tt
		hidden_effect = {
			event_target:to_be_overlord = { puppet = event_target:marked_country }
		}
		event_target:marked_country = { restore_previous_government_type = yes }
		if = {
			limit = {
				event_target:to_be_overlord = {
					is_in_faction = yes
					NOT = { is_in_faction_with = event_target:marked_country }
				}
			}
			event_target:to_be_overlord = {
				faction_leader = { add_to_faction = event_target:marked_country }
			}
		}
		clear_global_event_target = to_be_overlord
		add_to_variable = { ROOT.update_stt_gui = 1 }
	}
	option = {
		name = rf.political.250.c
		clear_global_event_target = to_be_overlord
	}
}

# Free Puppet
country_event = {
	id = rf.political.251
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.251 FROM = [From.GetName]" }
	title = rf.political.251.t
	desc = rf.political.251.d

	is_triggered_only = yes

	option = {
		name = rf.political.250.a
		event_target:marked_country = {
			overlord = {
				set_autonomy = {
					target = event_target:marked_country
					autonomy_state = autonomy_free
				}
			}
		}
		add_to_variable = { ROOT.update_stt_gui = 1 }
	}
	option = {
		name = rf.political.250.c
	}
}

# Add to Faction
country_event = {
	id = rf.political.252
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.252 FROM = [From.GetName]" }
	title = rf.political.252.t
	desc = rf.political.252.d

	is_triggered_only = yes

	option = {
		name = rf.political.250.a
		event_target:marked_country = {
			if = {
				limit = {
					is_in_faction = yes
					is_faction_leader = yes
				}
				dismantle_faction = yes
			}
			else_if = {
				limit = { is_in_faction = yes }
				leave_faction = yes
			}
		}
		event_target:to_be_faction_leader = {
			faction_leader = {
				add_to_faction = event_target:marked_country
			}
		}
		clear_global_event_target = to_be_faction_leader
		add_to_variable = { ROOT.update_stt_gui = 1 }
	}
	option = {
		name = rf.political.250.c
		clear_global_event_target = to_be_faction_leader
	}
}

# Make Faction Leader
country_event = {
	id = rf.political.253
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.253 FROM = [From.GetName]" }
	title = rf.political.253.t
	desc = rf.political.253.d

	is_triggered_only = yes

	option = {
		name = rf.political.250.a
		event_target:marked_country = {
			set_faction_leader = yes
		}
		add_to_variable = { ROOT.update_stt_gui = 1 }
	}
	option = {
		name = rf.political.250.c
	}
}

# Leave Faction
country_event = {
	id = rf.political.254
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.254 FROM = [From.GetName]" }
	title = rf.political.254.t
	desc = rf.political.254.d

	is_triggered_only = yes

	option = {
		name = rf.political.250.a
		event_target:marked_country = {
			if = {
				limit = {
					is_in_faction = yes
					is_faction_leader = yes
				}
				dismantle_faction = yes
			}
			else_if = {
				limit = { is_in_faction = yes }
				leave_faction = yes
			}
		}
		add_to_variable = { ROOT.update_stt_gui = 1 }
	}
	option = {
		name = rf.political.250.c
	}
}

# Peace
country_event = {
	id = rf.political.255
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.255 FROM = [From.GetName]" }
	title = rf.political.255.t
	desc = rf.political.255.d

	is_triggered_only = yes

	immediate = {
		hidden_effect = {
			event_target:marked_country = { save_event_target_as = white_peace_receiver }
		}
	}

	option = {
		name = rf.political.250.a
		event_target:peace_target = { white_peace_with_TARGET = yes }
		add_to_variable = { ROOT.update_stt_gui = 1 }
		clear_global_event_target = peace_target
	}
	option = {
		name = rf.political.255.b
		trigger = {
			event_target:marked_country = {
				OR = {
					is_subject = yes
					is_in_faction = yes
				}
			}
		}
		event_target:marked_country = {
			if = {
				limit = { is_subject = yes }
				overlord = {
					set_autonomy = {
						target = event_target:marked_country
						autonomy_state = autonomy_free
					}
				}
			}
			if = {
				limit = {
					is_in_faction = yes
					is_faction_leader = yes
				}
				dismantle_faction = yes
			}
			else_if = {
				limit = { is_in_faction = yes }
				leave_faction = yes
			}
		}
		event_target:peace_target = { white_peace_with_TARGET = yes }
		add_to_variable = { ROOT.update_stt_gui = 1 }
		clear_global_event_target = peace_target
	}
	option = {
		name = rf.political.250.c
		clear_global_event_target = peace_target
	}
}

# Peace Out Everyone
country_event = {
	id = rf.political.256
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.256 FROM = [From.GetName]" }
	title = rf.political.256.t
	desc = rf.political.256.d

	is_triggered_only = yes

	option = {
		name = rf.political.250.a
		event_target:marked_country = {
			if = {
				limit = { is_subject = yes }
				overlord = {
					set_autonomy = {
						target = event_target:marked_country
						autonomy_state = autonomy_free
					}
				}
			}
			if = {
				limit = {
					is_in_faction = yes
					is_faction_leader = yes
				}
				dismantle_faction = yes
			}
			else_if = {
				limit = { is_in_faction = yes }
				leave_faction = yes
			}
			separate_peace_all_wars = yes
		}
		add_to_variable = { ROOT.update_stt_gui = 1 }
	}
	option = {
		name = rf.political.250.c
	}
}

# Declare War
country_event = {
	id = rf.political.257
	immediate = { log = "[GetDateText]: [Root.GetName]: event rf.political.257 FROM = [From.GetName]" }
	title = rf.political.257.t
	desc = rf.political.257.d

	is_triggered_only = yes

	option = {
		name = rf.political.250.a
		event_target:marked_country = {
			declare_war_on = {
				target = event_target:war_target
				type = annex_everything
			}
			hidden_effect = {
				every_country = {
					limit = {
						is_ally_with = event_target:marked_country
						NOT = {
							tag = event_target:marked_country
							has_war_with = event_target:war_target
						}
					}
					meta_effect = {
						text = {
							add_to_war = {
								targeted_alliance = [ALLY]
								enemy = [ENEMY]
							}
						}
						ALLY = "[marked_country.GetTag]"
						ENEMY = "[war_target.GetTag]"
					}
				}
			}
		}
		clear_global_event_target = war_target
		add_to_variable = { ROOT.update_stt_gui = 1 }
	}
	option = {
		name = rf.political.250.c
		clear_global_event_target = war_target
	}
}


